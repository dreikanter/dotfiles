#!/usr/bin/env ruby

require "fileutils"
require "optparse"
require "json"

CONFIG_PATH = File.expand_path("~/.dotfiles/dotfiles.json").freeze

module Colors
  RED = "\033[31m"
  GREEN = "\033[32m"
  GRAY = "\033[90m"
  RESET = "\033[0m"
end

def colorize(text, color)
  return text if ENV["NO_COLOR"]
  "#{color}#{text}#{Colors::RESET}"
end

def load_configuration
  raw_config = JSON.parse(File.read(CONFIG_PATH))

  # Resolve directory destinations to full file paths
  raw_config.to_h do |local_path, dotfile_path|
    if dotfile_path.end_with?("/")
      src_filename = File.basename(local_path)
      resolved_dotfile_path = File.join(File.expand_path(dotfile_path), src_filename)
    else
      resolved_dotfile_path = File.expand_path(dotfile_path)
    end

    [File.expand_path(local_path), resolved_dotfile_path]
  end
rescue Errno::ENOENT
  puts colorize("Error:", Colors::RED) + " Configuration file not found: #{CONFIG_PATH}"
  exit 1
rescue JSON::ParserError => e
  puts colorize("Error:", Colors::RED) + " Invalid JSON in #{CONFIG_PATH}: #{e.message}"
  exit 1
end

def copy_file(src, dest, dry_run)
  src = File.expand_path(src)

  puts src
  puts colorize(dest, Colors::GRAY)

  unless File.exist?(src)
    puts colorize("Error:", Colors::RED) + " Source file not found: #{src}"
    puts
    return false
  end

  if dry_run
    puts colorize("OK", Colors::GREEN) + " (dry run)"
    puts
    return true
  end

  begin
    FileUtils.mkdir_p(File.dirname(dest))
    File.unlink(dest) if File.symlink?(dest)
    FileUtils.cp(src, dest)
    puts colorize("OK", Colors::GREEN)
    puts
    true
  rescue => e
    puts colorize("Error:", Colors::RED) + e.message
    puts
    false
  end
end

def save_dotfiles(config_files, dry_run)
  puts "local environment -> dotfiles#{" [DRY RUN]" if dry_run}"
  puts

  config_files.each do |local_path, dotfile_path|
    copy_file(local_path, dotfile_path, dry_run)
  end
end

def load_dotfiles(config_files, dry_run)
  puts "dotfiles -> local environment#{" [DRY RUN]" if dry_run}"
  puts

  config_files.each do |local_path, dotfile_path|
    copy_file(dotfile_path, local_path, dry_run)
  end
end

def list_managed_files(config_files)
  puts "Managed files:"
  puts

  config_files.each do |local_path, dotfile_path|
    local_exists = File.exist?(local_path)
    dotfile_exists = File.exist?(dotfile_path)

    status = case
             when local_exists && dotfile_exists
               colorize("✓", Colors::GREEN)
             when local_exists && !dotfile_exists
               colorize("L", Colors::GRAY)
             when !local_exists && dotfile_exists
               colorize("D", Colors::GRAY)
             else
               colorize("✗", Colors::RED)
             end

    puts "#{status} #{local_path}"
  end

  puts
  puts "Legend: ✓ = both exist, L = local only, D = dotfile only, ✗ = neither exist"
end

def show_config(config_files)
  puts JSON.pretty_generate(config_files)
end

# Parse arguments
options = { dry_run: false }

parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($0)} COMMAND [OPTIONS]"
  opts.separator "Manage dotfiles configuration"
  opts.separator ""
  opts.separator "Commands:"
  opts.separator "  save        Copy local environment configuration to dotfiles"
  opts.separator "  load        Load dotfiles configuration to local environment"
  opts.separator "  ls          List managed files with status"
  opts.separator "  config      Show configuration mapping as JSON"
  opts.separator ""
  opts.separator "Options:"

  opts.on("-n", "--dry-run", "Show what would be done") do
    options[:dry_run] = true
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit 0
  end
end

begin
  parser.parse!
rescue OptionParser::InvalidOption => e
  puts "Error: #{e}"
  puts parser
  exit 1
end

if ARGV.empty?
  puts parser
  exit 0
end

command = ARGV[0]
config_files = load_configuration

case command
when "save"
  save_dotfiles(config_files, options[:dry_run])
when "load"
  load_dotfiles(config_files, options[:dry_run])
when "ls"
  list_managed_files(config_files)
when "config"
  show_config(config_files)
else
  puts "Unknown command: #{command}"
  exit 1
end
