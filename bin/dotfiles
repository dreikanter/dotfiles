#!/usr/bin/env ruby

require "fileutils"
require "optparse"
require "json"
require "set"

CONFIG_PATH = File.expand_path("~/.dotfiles/dotfiles.json").freeze

module Colors
  RED = "\033[31m"
  GREEN = "\033[32m"
  GRAY = "\033[90m"
  RESET = "\033[0m"
end

def colorize(text, color)
  return text if ENV["NO_COLOR"]
  "#{color}#{text}#{Colors::RESET}"
end

def load_configuration(direction: :save)
  raw_config = JSON.parse(File.read(CONFIG_PATH))
  config_map = {}
  managed_dest_roots = []
  managed_dest_files = []
  expected_dest_files = Set.new

  raw_config.each do |dotfile_dir, local_paths|
    local_paths.each do |local_path|
      expanded_path = File.expand_path(local_path.sub(%r{/\*$}, "").sub(%r{/$}, ""))
      dotfiles_root = File.expand_path("~/.dotfiles/config/#{dotfile_dir}")

      local_base_dir = expanded_path
      local_root = File.dirname(local_base_dir)
      rel_prefix = local_base_dir.sub("#{local_root}/", "")
      dotfiles_base_dir = File.join(dotfiles_root, rel_prefix)

      # Treat as directory sync if the path is a directory on the source side,
      # or if the entry is explicitly marked with a trailing /* or /.
      is_dir_entry = local_path.end_with?("/*") || local_path.end_with?("/") || File.directory?(local_base_dir)
      is_dir_entry ||= (direction == :load && File.directory?(dotfiles_base_dir))

      if is_dir_entry

        if direction == :save
          managed_dest_roots << dotfiles_base_dir

          if File.directory?(local_base_dir)
            Dir.glob("#{local_base_dir}/**/*").each do |file|
              next unless File.file?(file)

              # Preserve the relative path structure
              rel_path = file.sub("#{local_root}/", "")
              dotfile_path = File.join(dotfiles_root, rel_path)
              config_map[file] = dotfile_path
              expected_dest_files << dotfile_path
            end
          end
        else
          managed_dest_roots << local_base_dir

          if File.directory?(dotfiles_base_dir)
            Dir.glob("#{dotfiles_base_dir}/**/*").each do |file|
              next unless File.file?(file)

              # Preserve the relative path structure
              rel_path = file.sub("#{dotfiles_root}/", "")
              local_file = File.join(local_root, rel_path)
              config_map[local_file] = file
              expected_dest_files << local_file
            end
          end
        end
      else
        # Single file - use original behavior
        src_filename = File.basename(local_path)
        dotfile_path = File.expand_path("~/.dotfiles/config/#{dotfile_dir}/#{src_filename}")
        config_map[expanded_path] = dotfile_path

        if direction == :save
          managed_dest_files << dotfile_path
          expected_dest_files << dotfile_path if File.file?(expanded_path)
        else
          managed_dest_files << expanded_path
          expected_dest_files << expanded_path if File.file?(dotfile_path)
        end
      end
    end
  end

  [config_map, {
    managed_dest_roots: managed_dest_roots,
    managed_dest_files: managed_dest_files,
    expected_dest_files: expected_dest_files
  }]
rescue Errno::ENOENT
  puts colorize("Error:", Colors::RED) + " Configuration file not found: #{CONFIG_PATH}"
  exit 1
rescue JSON::ParserError => e
  puts colorize("Error:", Colors::RED) + " Invalid JSON in #{CONFIG_PATH}: #{e.message}"
  exit 1
end

def copy_file(src, dest, dry_run: false, verbose: false)
  src = File.expand_path(src)
  puts src + "\n" + colorize(dest, Colors::GRAY) if verbose

  unless File.exist?(src)
    puts colorize("Error:", Colors::RED) + " Source file not found: #{src}" + "\n\n"
    return false
  end

  if dry_run
    puts colorize("OK", Colors::GREEN) + " (dry run)" if verbose
    puts if verbose
    return true
  end

  begin
    FileUtils.mkdir_p(File.dirname(dest))
    File.unlink(dest) if File.symlink?(dest)
    FileUtils.cp(src, dest)
    puts colorize("OK", Colors::GREEN) + "\n" if verbose
    true
  rescue => e
    puts colorize("Error:", Colors::RED) + e.message
    puts
    false
  end
end

def prune_destinations(managed_dest_roots:, managed_dest_files:, expected_dest_files:, dry_run: false, verbose: false)
  removed = 0
  removed_paths = Set.new

  managed_dest_roots.each do |root|
    next unless File.directory?(root)

    Dir.glob("#{root}/**/*").each do |path|
      next unless File.file?(path) || File.symlink?(path)
      next if expected_dest_files.include?(path)
      next if removed_paths.include?(path)

      if dry_run
        puts colorize("PRUNE", Colors::RED) + " #{path}" if verbose
      else
        FileUtils.rm_f(path)
      end

      removed_paths << path
      removed += 1
    end
  end

  managed_dest_files.each do |path|
    next unless File.exist?(path) || File.symlink?(path)
    next if expected_dest_files.include?(path)
    next if removed_paths.include?(path)

    if dry_run
      puts colorize("PRUNE", Colors::RED) + " #{path}" if verbose
    else
      FileUtils.rm_f(path)
    end

    removed_paths << path
    removed += 1
  end

  removed
end

def save_dotfiles(config_files, prune_meta, dry_run: false, verbose: false, prune: false)
  puts "local environment -> dotfiles#{" [DRY RUN]" if dry_run}" + "\n\n"

  success_count = 0
  errors_count = 0

  config_files.each do |local_path, dotfile_path|
    if copy_file(local_path, dotfile_path, dry_run: dry_run, verbose: verbose)
      success_count += 1
    else
      errors_count += 1
    end
  end

  pruned_count = prune ? prune_destinations(**prune_meta, dry_run: dry_run, verbose: verbose) : 0

  puts "Files copied: #{success_count}; errors: #{errors_count}"
  puts "Files removed: #{pruned_count}" if prune
  puts "All good" if errors_count.zero?
end

def load_dotfiles(config_files, prune_meta, dry_run: false, verbose: false, prune: false)
  puts "dotfiles -> local environment#{" [DRY RUN]" if dry_run}" + "\n\n"

  success_count = 0
  errors_count = 0

  config_files.each do |local_path, dotfile_path|
    if copy_file(dotfile_path, local_path, dry_run: dry_run, verbose: verbose)
      success_count += 1
    else
      errors_count += 1
    end
  end

  pruned_count = prune ? prune_destinations(**prune_meta, dry_run: dry_run, verbose: verbose) : 0

  puts "Files copied: #{success_count}; errors: #{errors_count}"
  puts "Files removed: #{pruned_count}" if prune
  puts "All good" if errors_count.zero?
end

def show_status(config_files)
  puts "Status of managed files:"
  puts

  config_files.each do |local_path, dotfile_path|
    status = status_text(local_path, dotfile_path)
    puts "#{status.ljust(30)} #{local_path}"
  end
end

def status_text(local_path, dotfile_path)
  local_exists = File.exist?(local_path)
  dotfile_exists = File.exist?(dotfile_path)

  case
  when !local_exists && !dotfile_exists
    colorize("neither exists", Colors::RED)
  when !local_exists && dotfile_exists
    colorize("local copy missing", Colors::GRAY)
  when local_exists && !dotfile_exists
    colorize("dotfile missing", Colors::GRAY)
  when local_exists && dotfile_exists
    if files_equal?(local_path, dotfile_path)
      colorize("in sync", Colors::GREEN)
    else
      local_mtime = File.mtime(local_path)
      dotfile_mtime = File.mtime(dotfile_path)

      if local_mtime > dotfile_mtime
        colorize("local changes", Colors::RED)
      else
        colorize("dotfile changes", Colors::RED)
      end
    end
  end
end

def files_equal?(file1, file2)
  return false unless File.exist?(file1) && File.exist?(file2)
  File.read(file1) == File.read(file2)
end

def show_config(config_files)
  puts JSON.pretty_generate(config_files.invert)
end

options = { dry_run: false }

parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($0)} COMMAND [OPTIONS]"
  opts.separator "Manage dotfiles configuration"
  opts.separator ""
  opts.separator "Commands:"
  opts.separator "  save        Copy local environment configuration to dotfiles"
  opts.separator "  load        Load dotfiles configuration to local environment"
  opts.separator "  status      Show status of managed files"
  opts.separator "  config      Show configuration mapping as JSON"
  opts.separator ""
  opts.separator "Options:"

  opts.on("-n", "--dry-run", "Show what would be done") do
    options[:dry_run] = true
  end

  opts.on("-v", "--verbose", "Verbose output") do
    options[:verbose] = true
  end

  opts.on("-p", "--prune", "Remove destination files missing from source") do
    options[:prune] = true
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit 0
  end
end

begin
  parser.parse!
rescue OptionParser::InvalidOption => e
  puts "Error: #{e}"
  puts parser
  exit 1
end

if ARGV.empty?
  puts parser
  exit 0
end

command = ARGV[0]
direction = command == "load" ? :load : :save
config_files, prune_meta = load_configuration(direction: direction)

case command
when "save"
  save_dotfiles(config_files, prune_meta, **options)
when "load"
  load_dotfiles(config_files, prune_meta, **options)
when "ls", "status"
  show_status(config_files)
when "config"
  show_config(config_files)
else
  puts "Unknown command: #{command}"
  exit 1
end
