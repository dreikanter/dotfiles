#!/usr/bin/env ruby

require "fileutils"
require "optparse"
require "json"

CONFIG_PATH = File.expand_path("~/.dotfiles/dotfiles.json").freeze

module Colors
  RED = "\033[31m"
  GREEN = "\033[32m"
  GRAY = "\033[90m"
  RESET = "\033[0m"
end

def colorize(text, color)
  return text if ENV["NO_COLOR"]
  "#{color}#{text}#{Colors::RESET}"
end

def load_configuration
  raw_config = JSON.parse(File.read(CONFIG_PATH))

  # Resolve directory destinations to full file paths
  raw_config.to_h do |local_path, dotfile_path|
    if dotfile_path.end_with?("/")
      src_filename = File.basename(local_path)
      resolved_dotfile_path = File.join(File.expand_path(dotfile_path), src_filename)
    else
      resolved_dotfile_path = File.expand_path(dotfile_path)
    end

    [File.expand_path(local_path), resolved_dotfile_path]
  end
rescue Errno::ENOENT
  puts colorize("Error:", Colors::RED) + " Configuration file not found: #{CONFIG_PATH}"
  exit 1
rescue JSON::ParserError => e
  puts colorize("Error:", Colors::RED) + " Invalid JSON in #{CONFIG_PATH}: #{e.message}"
  exit 1
end

def copy_file(src, dest, dry_run: false, verbose: false)
  src = File.expand_path(src)
  puts src + "\n" + colorize(dest, Colors::GRAY) if verbose

  unless File.exist?(src)
    puts colorize("Error:", Colors::RED) + " Source file not found: #{src}" + "\n\n"
    return false
  end

  if dry_run
    puts colorize("OK", Colors::GREEN) + " (dry run)" if verbose
    puts if verbose
    return true
  end

  begin
    FileUtils.mkdir_p(File.dirname(dest))
    File.unlink(dest) if File.symlink?(dest)
    FileUtils.cp(src, dest)
    puts colorize("OK", Colors::GREEN) + "\n" if verbose
    true
  rescue => e
    puts colorize("Error:", Colors::RED) + e.message
    puts
    false
  end
end

def save_dotfiles(config_files, dry_run: false, verbose: false)
  puts "local environment -> dotfiles#{" [DRY RUN]" if dry_run}" + "\n\n"

  success_count = 0
  errors_count = 0

  config_files.each do |local_path, dotfile_path|
    if copy_file(local_path, dotfile_path, dry_run: dry_run, verbose: verbose)
      success_count += 1
    else
      errors_count += 1
    end
  end

  puts "Files copied: #{success_count}; errors: #{errors_count}"
  puts "All good" if errors_count.zero?
end

def load_dotfiles(config_files, dry_run: false, verbose: false)
  puts "dotfiles -> local environment#{" [DRY RUN]" if dry_run}" + "\n\n"

  success_count = 0
  errors_count = 0

  config_files.each do |local_path, dotfile_path|
    if copy_file(dotfile_path, local_path, dry_run: dry_run, verbose: verbose)
      success_count += 1
    else
      errors_count += 1
    end
  end

  puts "Files copied: #{success_count}; errors: #{errors_count}"
  puts "All good" if errors_count.zero?
end

def show_status(config_files)
  puts "Status of managed files:"
  puts

  config_files.each do |local_path, dotfile_path|
    status = status_text(local_path, dotfile_path)
    puts "#{status.ljust(30)} #{local_path}"
  end
end

def status_text(local_path, dotfile_path)
  local_exists = File.exist?(local_path)
  dotfile_exists = File.exist?(dotfile_path)

  case
  when !local_exists && !dotfile_exists
    colorize("neither exists", Colors::RED)
  when !local_exists && dotfile_exists
    colorize("local copy missing", Colors::GRAY)
  when local_exists && !dotfile_exists
    colorize("dotfile missing", Colors::GRAY)
  when local_exists && dotfile_exists
    if files_equal?(local_path, dotfile_path)
      colorize("in sync", Colors::GREEN)
    else
      local_mtime = File.mtime(local_path)
      dotfile_mtime = File.mtime(dotfile_path)

      if local_mtime > dotfile_mtime
        colorize("local changes", Colors::RED)
      else
        colorize("dotfile changes", Colors::RED)
      end
    end
  end
end

def files_equal?(file1, file2)
  return false unless File.exist?(file1) && File.exist?(file2)
  File.read(file1) == File.read(file2)
end

def show_config(config_files)
  puts JSON.pretty_generate(config_files.invert)
end

options = { dry_run: false }

parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($0)} COMMAND [OPTIONS]"
  opts.separator "Manage dotfiles configuration"
  opts.separator ""
  opts.separator "Commands:"
  opts.separator "  save        Copy local environment configuration to dotfiles"
  opts.separator "  load        Load dotfiles configuration to local environment"
  opts.separator "  status      Show status of managed files"
  opts.separator "  config      Show configuration mapping as JSON"
  opts.separator ""
  opts.separator "Options:"

  opts.on("-n", "--dry-run", "Show what would be done") do
    options[:dry_run] = true
  end

  opts.on("-v", "--verbose", "Verbose output") do
    options[:verbose] = true
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit 0
  end
end

begin
  parser.parse!
rescue OptionParser::InvalidOption => e
  puts "Error: #{e}"
  puts parser
  exit 1
end

if ARGV.empty?
  puts parser
  exit 0
end

command = ARGV[0]
config_files = load_configuration

case command
when "save"
  save_dotfiles(config_files, **options)
when "load"
  load_dotfiles(config_files, **options)
when "ls", "status"
  show_status(config_files)
when "config"
  show_config(config_files)
else
  puts "Unknown command: #{command}"
  exit 1
end
